{"id": "fc2264", "title": "How do you make a python program to calculate the derivative or integration of an expression without using sympy?", "url": "https://www.reddit.com/r/learnpython/comments/fc2264/how_do_you_make_a_python_program_to_calculate_the/", "subreddit": "learnpython", "author": "t2_3m2ck6vi", "text": "So I want to make a program for my calculator that allows it to manipulate symbolically however sympy is too huge to fit in my calculator's measly 16 MB so I'm asking for help, if there is one already.", "comments": [{"id": "fj83agt", "author": "programmingfriend", "body": "Symbolic algebra is hard. that is why sympy is very large. Look into the concept of [tokenization](https://stackoverflow.com/questions/20805614/tokenize-a-mathematical-expression-in-python). It is a subject that goes as deep as you would like it to. You may be able to implement an algebraic solver yourself for most trivial cases."}, {"id": "fj84ubj", "author": "gatherinfer", "body": "You'll only be able to easily do it for a subset of functions -- polynomials, trig functions, exponential function, etc. If you want the whole thing to be symbolic, you'll probably need to write some classes that can represent these functions, and write methods for adding, subtracting, multiplying them etc, and methods for integrating and differentiating.\n\nE.g. you can represent a polynomial as a list of coefficients starting with the constant term:\n\n    from itertools import zip_longest\n\n    class Polynomial:\n        def __init__(self, coefficients):\n            self.coefficients = coefficients\n            \n        @property\n        def order(self):\n            return len(self.coefficients) - 1\n        \n        def derivative(self):\n            return Polynomial([i*j for i,j in enumerate(self.coefficients)][1:])\n        \n        def __add__(self, other):\n            return Polynomial([i + j for i, j in zip_longest(self.coefficients, other.coefficients, fillvalue=0)])\n        \n        def __repr__(self):\n            return f\"Polynomial({list(self.coefficients)})\"\n            \n        def __str__(self):\n            return \" + \".join(reversed([f\"{j}x^{i}\" for i, j in enumerate(self.coefficients)]))\n        \n        def __call__(self, x):\n            return sum(j*(x**i) for i, j in enumerate(self.coefficients))\n\nThen you can do:\n\n    >>> poly1 = Polynomial([3, -5, 7])\n    >>> poly2 = Polynomial([9, 2, -4, 5])\n    >>> poly1\n    Polynomial([3, -5, 7])\n    >>> poly2\n    Polynomial([9, 2, -4, 5])\n    >>> print(poly1)\n    7x^2 + -5x^1 + 3x^0\n    >>> print(poly2)\n    5x^3 + -4x^2 + 2x^1 + 9x^0\n    >>> poly3 = poly1 + poly2\n    >>> poly3\n    Polynomial([12, -3, 3, 5])\n    >>> print(poly3)\n    5x^3 + 3x^2 + -3x^1 + 12x^0\n    >>> poly4 = poly3.derivative()\n    >>> poly4\n    Polynomial([-3, 6, 15])\n    >>> print(poly4)\n    15x^2 + 6x^1 + -3x^0\n    >>> poly1.order\n    2\n    >>> poly3.order\n    3\n    >>> poly1(2) == 7*(2**2) -5*2 + 3\n    True\n\nThe methods with the double-underscore are called \"dunder\" methods or \"magic\" methods, they are how you tell the class how it should work when you use arithmetic operations or call it as a function and so on. Read about it more [here](https://docs.python.org/3/reference/datamodel.html#special-method-names).\n\nBut this approach will start to break down as you try to extend it to other function types. If you write a class for exponential functions, you'll need to add in logic for how polynomials interact with exponentials. And again if you add trig functions, and so on. The number of combinations grows very fast. Symbolic algebra is a hard problem.\n\n(Here's a fun exercise that will teach you about [duck typing](https://en.wikipedia.org/wiki/Duck_typing): figure out what you need to implement so that `poly1(poly2)` gives the correct answer.)\n\nAre you sure your calculator can't do symbolic math already? It seems weird to me that it could run Python and not have that capability built in."}]}